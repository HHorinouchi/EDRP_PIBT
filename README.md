## To use GUI for task

Enable the following in init()
```
if self.is_tasklist:
	self.taskgui=GUI_tasklist()
```

- 実行は`task_test.py`を参照

```
actions, task = policy(n_obs, env)
joint_action = {"pass": actions, "task": task}
n_obs, reward, done, info = env.step(joint_action)
```

- `"pass"`は従来のdrpの入力と同じ
- `"task"`はエージェントへのタスクの割り当てを表し，サイズはエージェント数のリストとする．
	- 割り当てはタスクリスト`env.current_tasklist`の何番目のタスクかを表す（0~）
	- 割り当てを行わない場合は`-1`とする（例：エージェント数4，`task = [-1,0,1,-1]`）

- 必要な情報
	- `env.current_tasklist`：現在のすべての未実行状態のタスクのリスト  
	（例：タスク数3，`[[1,2],[5,3],[8,9]]`）
	- `env.assigned_list`：未実行のタスクがどのエージェントに割り当てられているかのリスト．割り当てられていない場合は-1  
	（例：タスク数3，タスク2が割り当てられていない．`[1,0,-1]`）
	- `env.assigned_tasks`：各エージェントに割り当てられたタスクの情報．実行中のものも含む  
	（例：エージェント数3，エージェント2はタスクを割り当てられていない．`[[1,2],[3,4],[]]`）


• Deadlock 回避レポート

  - 問題背景: policy/my_policy.py の従来ロジックは PIBT ベースで最短経路を優先しつつノード/エッジ占有を避けていましたが、互いに同じノードを譲り合うだけの状態に陥った場合は回避手段がなく、複数ステップにわた
    り行動不能 (デッドロック) が発生していました。
  - スタック検知の導入 (update_stall_tracker)
      - 直近に到達すべきゴールと現在位置を監視し、指定ステップ数 (STALL_THRESHOLD=3) 連続で同じノードに留まっているエージェントを「停滞中」とみなします。
      - 前ステップの位置配列 _PREV_POSITIONS と滞留回数 _STALL_COUNTS をグローバルに保持し、ステップごとに更新して停滞エージェント集合 stalled_agents を返します。
  - 優先度への反映 (detect_actions)
      - PIBT 優先度計算を「短距離優先→滞留回数の多いエージェント優先」の複合ソートに変更。デッドロック候補が先に行動案内されるため、上位者の再選択処理でも救済されやすくなります。
  - 強制迂回 (enforce_deadlock_escape)
      - 行動確定後に停滞エージェントだけを再評価し、その場待機や逆走ではなく「現ノード≠候補」で、かつ他エージェントの予定ターゲットと衝突しない行動をランダム順で探索します。
      - conflicts_with_targets でノード共有やエッジ入れ替わりを弾き、安全な候補を見つけた時点で行動を上書き。候補がなければ従来行動を維持しつつ次ステップで再挑戦します。
  - 期待効果
      1. 可視化された停滞検知により、長時間動かないエージェントを特定。
      2. 優先度ブーストでスタックエージェントの行動決定順を引き上げ、上位エージェントの行動リセットに巻き込まれにくく。
      3. ランダム迂回行動を単独エージェントに適用することで、互いに譲らないノード争いや対向エッジ衝突を明示的に解消。
  - 運用上の注意
      - 阈値 STALL_THRESHOLD は環境速度やマップ密度に応じて調整可能。
      - 迂回候補は env.get_avail_agent_actions から抽出しており、環境側の安全判定に従うため追加の衝突判定は簡略化されています。
      - さらに頑健性を高めたい場合は CBS ベース共通経路と組み合わせたり、停滞検知の履歴長を状況に応じて変えると良いでしょう。

  この手法により、タスク優先の動線を維持しつつ、長期停滞が発生した際に局所的な回避行動を注入できるようになりました。